_mm_testz_pd
^^^^^^^^^^^^
:Tech: AVX_ALL
:Category: Logical
:Header: immintrin.h
:Register: XMM 128 bit
:Return Type: int
:Param Types:
    __m128d a, 
    __m128d b
:Param ETypes:
    FP64 a, 
    FP64 b

.. code-block:: C

    int _mm_testz_pd(__m128d a, __m128d b);

.. admonition:: Intel Description

    Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return the "ZF" value.

.. admonition:: Intel Implementation Psudeo-Code

    .. code-block:: text

        
        tmp[127:0] := a[127:0] AND b[127:0]
        IF (tmp[63] == 0 && tmp[127] == 0)
        	ZF := 1
        ELSE
        	ZF := 0
        FI
        tmp[127:0] := (NOT a[127:0]) AND b[127:0]
        IF (tmp[63] == 0 && tmp[127] == 0)
        	CF := 1
        ELSE
        	CF := 0
        FI
        dst := ZF
        	

_mm_testc_pd
^^^^^^^^^^^^
:Tech: AVX_ALL
:Category: Logical
:Header: immintrin.h
:Register: XMM 128 bit
:Return Type: int
:Param Types:
    __m128d a, 
    __m128d b
:Param ETypes:
    FP64 a, 
    FP64 b

.. code-block:: C

    int _mm_testc_pd(__m128d a, __m128d b);

.. admonition:: Intel Description

    Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return the "CF" value.

.. admonition:: Intel Implementation Psudeo-Code

    .. code-block:: text

        
        tmp[127:0] := a[127:0] AND b[127:0]
        IF (tmp[63] == 0 && tmp[127] == 0)
        	ZF := 1
        ELSE
        	ZF := 0
        FI
        tmp[127:0] := (NOT a[127:0]) AND b[127:0]
        IF (tmp[63] == 0 && tmp[127] == 0)
        	CF := 1
        ELSE
        	CF := 0
        FI
        dst := CF
        	

_mm_testnzc_pd
^^^^^^^^^^^^^^
:Tech: AVX_ALL
:Category: Logical
:Header: immintrin.h
:Register: XMM 128 bit
:Return Type: int
:Param Types:
    __m128d a, 
    __m128d b
:Param ETypes:
    FP64 a, 
    FP64 b

.. code-block:: C

    int _mm_testnzc_pd(__m128d a, __m128d b);

.. admonition:: Intel Description

    Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return 1 if both the "ZF" and "CF" values are zero, otherwise return 0.

.. admonition:: Intel Implementation Psudeo-Code

    .. code-block:: text

        
        tmp[127:0] := a[127:0] AND b[127:0]
        IF (tmp[63] == 0 && tmp[127] == 0)
        	ZF := 1
        ELSE
        	ZF := 0
        FI
        tmp[127:0] := (NOT a[127:0]) AND b[127:0]
        IF (tmp[63] == 0 && tmp[127] == 0)
        	CF := 1
        ELSE
        	CF := 0
        FI
        IF (ZF == 0 && CF == 0)
        	dst := 1
        ELSE
        	dst := 0
        FI
        	

_mm_testz_ps
^^^^^^^^^^^^
:Tech: AVX_ALL
:Category: Logical
:Header: immintrin.h
:Register: XMM 128 bit
:Return Type: int
:Param Types:
    __m128 a, 
    __m128 b
:Param ETypes:
    FP32 a, 
    FP32 b

.. code-block:: C

    int _mm_testz_ps(__m128 a, __m128 b);

.. admonition:: Intel Description

    Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return the "ZF" value.

.. admonition:: Intel Implementation Psudeo-Code

    .. code-block:: text

        
        tmp[127:0] := a[127:0] AND b[127:0]
        IF (tmp[31] == 0 && tmp[63] == 0 && tmp[95] == 0 && tmp[127] == 0)
        	ZF := 1
        ELSE
        	ZF := 0
        FI
        tmp[127:0] := (NOT a[127:0]) AND b[127:0]
        IF (tmp[31] == 0 && tmp[63] == 0 && tmp[95] == 0 && tmp[127] == 0)
        	CF := 1
        ELSE
        	CF := 0
        FI
        dst := ZF
        	

_mm_testc_ps
^^^^^^^^^^^^
:Tech: AVX_ALL
:Category: Logical
:Header: immintrin.h
:Register: XMM 128 bit
:Return Type: int
:Param Types:
    __m128 a, 
    __m128 b
:Param ETypes:
    FP32 a, 
    FP32 b

.. code-block:: C

    int _mm_testc_ps(__m128 a, __m128 b);

.. admonition:: Intel Description

    Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return the "CF" value.

.. admonition:: Intel Implementation Psudeo-Code

    .. code-block:: text

        
        tmp[127:0] := a[127:0] AND b[127:0]
        IF (tmp[31] == 0 && tmp[63] == 0 && tmp[95] == 0 && tmp[127] == 0)
        	ZF := 1
        ELSE
        	ZF := 0
        FI
        tmp[127:0] := (NOT a[127:0]) AND b[127:0]
        IF (tmp[31] == 0 && tmp[63] == 0 && tmp[95] == 0 && tmp[127] == 0)
        	CF := 1
        ELSE
        	CF := 0
        FI
        dst := CF
        	

_mm_testnzc_ps
^^^^^^^^^^^^^^
:Tech: AVX_ALL
:Category: Logical
:Header: immintrin.h
:Register: XMM 128 bit
:Return Type: int
:Param Types:
    __m128 a, 
    __m128 b
:Param ETypes:
    FP32 a, 
    FP32 b

.. code-block:: C

    int _mm_testnzc_ps(__m128 a, __m128 b);

.. admonition:: Intel Description

    Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return 1 if both the "ZF" and "CF" values are zero, otherwise return 0.

.. admonition:: Intel Implementation Psudeo-Code

    .. code-block:: text

        
        tmp[127:0] := a[127:0] AND b[127:0]
        IF (tmp[31] == 0 && tmp[63] == 0 && tmp[95] == 0 && tmp[127] == 0)
        	ZF := 1
        ELSE
        	ZF := 0
        FI
        tmp[127:0] := (NOT a[127:0]) AND b[127:0]
        IF (tmp[31] == 0 && tmp[63] == 0 && tmp[95] == 0 && tmp[127] == 0)
        	CF := 1
        ELSE
        	CF := 0
        FI
        IF (ZF == 0 && CF == 0)
        	dst := 1
        ELSE
        	dst := 0
        FI
        	

